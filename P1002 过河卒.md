# P1002 [NOIP 2002 普及组] 过河卒

## 题目描述

棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。

棋盘用坐标表示，$ A $ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。

![](https://cdn.luogu.com.cn/upload/image_hosting/ipmwl52i.png)

现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。

## 输入格式

一行四个正整数，分别表示 $B$ 点坐标和马的坐标。

## 输出格式

一个整数，表示所有的路径条数。

## 输入输出样例 #1

### 输入 #1

```
6 6 3 3
```

### 输出 #1

```
6
```

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n, m \le 20$，$0 \le$ 马的坐标 $\le 20$。

**【题目来源】**

NOIP 2002 普及组第四题

## 题解思路

一道入门的$dp$问题。棋子要从$(0,0)$到达目标位置，每次只能向下或向右走不能回头，需要找出到达目标位置的路径条数。

容易想到到达某个位置的路径条数应为到达该位置之前所在的两个位置的路径条数之和。

假设目前到达$(n,m)$，那么到达该位置的路径条数  $f_{n,m}$=$f_{n-1,m}+f_{n,m-1}$，得到转移方程。

剩下只需要在到达某个位置时判断该位置是否满足马的控制点的条件，如果不满足则使用转移方程计算该点的路径条数；满足的话则该点的路径条数直接为$0$即可。

此时测试输入样例成功得到预期输出，程序的时间复杂度为$O(nm)$，空间复杂度也为$O(nm)$。

$dp$需要遍历所有棋子位置，时间复杂度显然无法进行优化，但空间复杂度似乎还有优化空间。

按照二维$dp$的思路，开了一个$n*m$的二维数组，如果只开一个大小为$m$的一维数组是否可行？

当然可以！既然只开了大小为m的一维数组，那么数组代表的意义不再是到达$(n,m)$位置对应的路径条数，而是到达第$m$列对应的路径条数，但同一时间只对应同一列的路径条数。

现在来改写转移方程，原来的$f_{n,m}$理所当然改为$f_m$。如果我们在遍历每一行时采取从0到m的方向，那么当我们要更新$f_m$时，此前的$f_{m-1}$已经被更新为这一行的路径条数，对应原来转移方程中的$f_{n,m-1}$，而$f_m$尚未被更新，对应原来转移方程中的$f_{n-1,m}$。那么转移方程就可以改写为$f_{m}$=$f_{m}+f_{m-1}$。

根据新的转移方程去进行$dp$求解就成功降低了空间复杂度，此时空间复杂度为$O(m)$。

## 代码

```c++
#include <bits/stdc++.h>
using namespace std;
int n,m,a,b;
int judge(int x,int y){
    int t=(x-a)*(x-a)+(y-b)*(y-b);
    if(t==5 || t==0) return 1;
    return 0;
}
int main() {
    cin>>n>>m>>a>>b;
    long long result[m+1];
    for(int j=0;j<=m;j++){
        result[j]=1;
    }
    for(int i=0;i<=n;i++){
        for(int j=0;j<=m;j++){
            if(judge(i,j)){
                result[j]=0;
                continue;
            }
            if(i==0&&j!=0){
                result[j]=result[j-1];
            }
            if(j==0&&i!=0){
                result[j]=result[j];
            }
            if(i>0&&j>0){
                result[j]=result[j-1]+result[j];
            }
        }
    }
    cout<<result[m]<<endl;
    return 0;
}
```


